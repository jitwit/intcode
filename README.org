#+options: num:nil

* Intcode Interpreter

For advent of code 2019, an byte language called intcode was the
assembly language. An intcode program is a list of comma-seperated
ints. This is a literate program that intreprets intcode programs.

** Internals

*** Local State

The internal state of an instance of an "intcode machine" has a few
compoents:

#+name: intcode-local-state
#+begin_src scheme :session :exports code
(define ip 0)                           ; instruction pointer
(define relative-base 0)                ; offset pointer
(define memory-1 `#(,@program))         ; memory (also initially the program)
(define memory-2 (make-eq-hashtable))   ; extra memory for out of range references
(define in '())                         ; input signals
(define out '())                        ; output signals
(define size (vector-length memory-1))  ; size (for use in indexing)
(define status 'ok)                     ; status for querying
#+end_src

#+RESULTS: intcode-local-state

A hashtable is used for the second level of member because it will
rarely be needed because the spec wants it to handle possibly very out
of range addresses.

*** Resets

The ~memory-1~ is copied to a vector from the input program to make
restarts easier. The following internal function is called upon
receiving a request to reset:

#+name: reset
#+begin_src scheme :session
(define (reset!)
  (set! memory-1 `#(,@program))
  (set! memory-2 (make-eq-hashtable))
  (set! ip 0)
  (set! relative-base 0)
  (set! in '())
  (set! out '())
  (set! status 'ok))
#+end_src

*** Incrementing Pointers

A few (unnecessary, but convenient) helpers to increment the pointers

#+name: increment
#+begin_src scheme :session
(define (ip! dx)
  (set! ip (fx+ ip dx)))

(define (rb! dx)
  (set! relative-base (fx+ relative-base dx)))
#+end_src

*** Store & Load Instructions

The local variable size is used to decide which level of memory to
load or store values. These two functions are the final step after
decoding the opcode and how it indicates the parameters should be
referenced. Getting this right was easily the most unpleasant part of
implementing the intcode spec.

#+name: store/load
#+begin_src scheme :session
(define (store! addr val)
  (if (fx< addr size)
      (vector-set! memory-1 addr val)
      (hashtable-set! memory-2 addr val)))

(define (ref addr)
  (if (fx< addr size)
      (vector-ref memory-1 addr)
      (hashtable-ref memory-2 addr 0)))
#+end_src

So, the first two digits (little endian) of an instruction that's been
pointed to by ~ip~ determine which instruction to do. The other digits
determine how the arguments for the instruction are referenced.
- 0 => ~mem[mem[ip+param]]~ reference twice like 2 but without
  relative base pointer.
- 1 => ~mem[ip + param]~ the simple case, no gymnastics.
- 2 => ~mem[rb + mem[ip+param]]~ reference the parameter then use
  relative base to reference once more.

It is not strictly necessary to split up ~val~ and ~addr~, but it's a
slight convenience and helps avoid decoding the opcode digits multiple
times for parameters. *Actually!* Writing this up helped me spot a
problem, in ~step~ digits should be decoded once and not within the
~val~ and ~addr~ functions!. Seeming more and more like literate
programming is useful, though more work... *fixme!*

#+name: val/addr
#+begin_src scheme :session
(define (val opcode param)
  (case (digit-at param opcode)
    ((1) (ref (fx+ ip param)))
    ((2) (ref (fx+ relative-base (ref (fx+ ip param)))))
    ((0) (ref (ref (fx+ ip param))))))

(define (addr opcode param)
  (case (digit-at param opcode)
    ((2) (fx+ relative-base (ref (fx+ ip param))))
    ((0) (ref (fx+ ip param)))
    ((1) (error 'intcode "addr is immediate" opcode param))))
#+end_src

The wonky ordering of the modes is informed by profiling the various
puzzles using chez's lovely tooling.

*** Small Steps

For maximal flexibility, I implement the interpreting as small
step. This means the owner of an intcode cell can have fine-grained
control over how it wants to run an intcode program. Opcodes
correspond to the following operations:
- 1 => add
- 2 => mul
- 3 => read in
- 4 => put out
- 5 => jump if not zero
- 6 => jump if zero
- 7 => store comparison <
- 8 => store comparison =
- 9 => increment relative base
- 99 => finish

#+name: small-step
#+begin_src scheme :session
(define (step)
  (let ((op (ref ip)))
    (case (fxmod op 100)
      ((1) (store! (addr op 3) (fx+ (val op 1) (val op 2))) (ip! 4))
      ((2) (store! (addr op 3) (fx* (val op 1) (val op 2))) (ip! 4))
      ((3) (if (null? in) (set! status 'blocking-in)
               (begin (set! status 'ok) (store! (addr op 1) (pop! in)) (ip! 2))))
      ((4) (set! status 'out) (push! (val op 1) out) (ip! 2))
      ((5) (if (fxzero? (val op 1)) (ip! 3) (set! ip (val op 2))))
      ((6) (if (fxzero? (val op 1)) (set! ip (val op 2)) (ip! 3)))
      ((7) (store! (addr op 3) (if (fx< (val op 1) (val op 2)) 1 0)) (ip! 4))
      ((8) (store! (addr op 3) (if (fx= (val op 1) (val op 2)) 1 0)) (ip! 4))
      ((9) (rb! (val op 1)) (ip! 2))
      ((99) (set! status 'done))
      (else (error 'intcode "bad opcode" op)))))
#+end_src

*** Interface from Messages

Being local state cells, these things dispatch on request messages à
la SICP and scheme tradition. Here is the handler and the final
expression in the ~incode~ definition's body:

#+name: intcode-handler
#+begin_src scheme :session
(lambda (me . args)
  (case me
    ;; by default status is ok and any other states will be detected
    ;; in step (blocking-in, done, and out)
    ((step) (set! status 'ok) (step) status)
    ;; args represent input signals. generally 1 will be fed at a time
    ;; but this allows for more.
    ((in) (set! in `(,@in ,@args)) (set! status 'ok))
    ;; read the most recent output signal (car), without popping it.
    ((out) (if (null? out) 'no-out (car out)))
    ;; query the status/state of the cell
    ((status) status)
    ;; read the whole output, flushing it, and return in chronological
    ;; order.
    ((read-out!) (let ((tmp (reverse out))) (set! out '()) tmp))
    ;; the following are mostly for debugging and inspection
    ((peek-in) in)
    ((ip) ip)
    ((rb) relative-base)
    ((ref) (apply ref args))
    ((store!) (apply store! args))
    ((reset!) (reset!))
    ((program) program)
    (else (error 'cpu "unknown message" me))))
#+end_src

** (intcode program)

Bringing the internals together:

#+name: intcode
#+begin_src scheme :session :noweb yes
(define (intcode program)
  <<intcode-local-state>>

  <<reset>>

  <<increment>>

  <<store/load>>

  <<val/addr>>

  <<small-step>>

  <<intcode-handler>>)
#+end_src

#+begin_src scheme :session
(define (read-memory M addr)
  (M 'ref addr))

(define (store! M addr val)
  (M 'store! addr val))

(define (reset! M)
  (M 'reset!))

(define (step M)
  (M 'step))

(define (run M)
  (M 'run))

(define (send-input M value)
  (M 'in value))

(define (send-input* M values)
  (apply M 'in values))

(define (read-output M)
  (M 'read-out!))

(define (get-input M)
  (M 'peek-in))

(define (get-output M)
  (M 'out))

(define (status M)
  (M 'status))

(define (run-until status M)
  (let run ((s (step M)))
    (if (memq s status) s (run (step M)))))

(define (run-until-halt M)
  (run-until '(done blocking-in) M))

(define (halt M)
  (run-until '(done blocking-in) M))

(define (done? M)
  (eq? 'done (status M)))

(define (blocked? M)
  (eq? 'blocking-in (status M)))

(define (run-intcode program . inputs)
  (define M (intcode program))
  (apply M 'in inputs)
  (run-until-halt M)
  (read-output M))
#+end_src

* Coda

More than anything the exercise of making this literate is convincing
me that Knuth is right about literate programming. Granted, this isn't
exactly the most complicated or large scale project, but splicing the
various pieces together literately is easy as π.
